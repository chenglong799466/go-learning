# go变量的申明和初始化

声明：

1. var 变量名字 类型 = 表达式
2. 使用new()函数
   初始化：
   其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
2. 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。
3. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在**Go语言中不存在未初始化的变量**。

# go的：=和=

请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。

# go变量的定义和理解

一个变量对应一个保存了变量对应类型值的内存空间。

# go指针的理解

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。
并不是每一个值都会有一个内存地址，但是**每一个变量必然有对应的内存地址**。
通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）

指针声明
要想使用指针必选先声明
var var_name *var_type // var_name 指针名称，var_type 指针所指向的变量的类型

var_type= *string 只能赋值string类型，否则会报错。

指针也是可以比较的
必须是指向同一个地址的指针才相等

# go的&取地址和*取值操作符

*取值
因为一个指针的值是另一个变量的地址，所以对指针取值实际是取指针的值（另一个变量的地址）的值。
&取地址
每一个变量都可以取地址，重复使用&取地址，相当于层层调用。

# go变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。
全局变量： 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
局部变量： 而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

# go的局部变量逃逸是什么？变量的分配？

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择**并不是**由用var还是new声明变量的方式决定的。
逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

```go
package main

var global *int

func f() {
	var x int
	x = 1
	global = &x // x局部变量从函数中逃逸了，拥有整个程序的生命周期。这对这个局部的垃圾回收是有影响的
}

func g() {
	y := new(int)
	*y = 1
}
```

# go的包初始化过程。init函数

1. 如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。（同包下的不同 go 文件，按照文件名“从小到大”排序顺序执行）
2. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。（比如a包在b，c都有引用，a包也只会初始化一次。自下而上的初始化）
3. 在 main 包中的 go 文件默认总是会被执行
4. 其他的包只有被 main 包 import 才会执行，按照 import 的先后顺序执行
5. main 包总是被最后一个初始化，因为它总是依赖别的包
6. 避免出现循环 import，例如：A –> B –> C –> A
7. 同一个go文件的初始化顺序，常量，变量，init（）（一个文件可以有多个，多个从上至下执行），main（）（只能在main包下，只能有一个）
```go
package main

// 这个不会报编译错误
func init() {

}
func init() {

}
func init() {

}
func init() {

}
```





